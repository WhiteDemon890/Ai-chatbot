import React, { useState } from 'react';
import { Box, Button, Card, CardContent, Typography, RadioGroup, FormControlLabel, Radio, Alert, CircularProgress, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow } from '@mui/material';
import { CloudUpload, Description, Quiz, Score } from '@mui/icons-material';

// Configuration
const API_KEY = process.env.REACT_APP_GOOGLE_API_KEY || "AIzaSyDv-uu_Y3NU1h7pJ4JlrrXI4yeGHqR0GgY";
const POINTS_PER_QUESTION = 10;

const PdfToQuiz = () => {
  const [file, setFile] = useState(null);
  const [loading, setLoading] = useState(false);
  const [quizData, setQuizData] = useState(null);
  const [userAnswers, setUserAnswers] = useState([]);
  const [score, setScore] = useState(0);
  const [showResults, setShowResults] = useState(false);
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [error, setError] = useState('');
  const [pdfText, setPdfText] = useState('');

  // Load PDF.js dynamically
  const loadPdfJs = async () => {
    if (window.pdfjsLib) return window.pdfjsLib;
    
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js';
    script.onload = () => {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    };
    document.head.appendChild(script);
    
    return new Promise(resolve => {
      script.onload = () => resolve(window.pdfjsLib);
    });
  };

  const extractTextFromPDF = async (file) => {
    try {
      const pdfjsLib = await loadPdfJs();
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      let text = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        text += textContent.items.map(item => item.str).join(' ') + '\n';
      }
      
      return text;
    } catch (err) {
      throw new Error('Failed to extract text from PDF: ' + err.message);
    }
  };

  const callGeminiAPI = async (prompt) => {
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      return data.candidates[0].content.parts[0].text;
    } catch (err) {
      throw new Error('Gemini API call failed: ' + err.message);
    }
  };

  const summarizeText = async (text) => {
    const prompt = `Summarize the following text in 3-5 sentences:\n\n${text.substring(0, 3000)}`;
    return await callGeminiAPI(prompt);
  };

  const generateQuiz = async (summary) => {
    const prompt = `Create 5 multiple-choice questions from the following summary.
Each question must have 4 options and one correct answer.
Return JSON like this:

{
  "questions": [
    {
      "question": "Question text",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
      "correctAnswer": "Option 2"
    }
  ]
}

Summary: ${summary.substring(0, 2000)}`;

    const response = await callGeminiAPI(prompt);
    const jsonText = response.replace(/```json|```/g, '').trim();
    return JSON.parse(jsonText);
  };

  const handleFileUpload = (event) => {
    const selectedFile = event.target.files[0];
    if (selectedFile && selectedFile.type === 'application/pdf') {
      setFile(selectedFile);
      setError('');
    } else {
      setError('Please select a valid PDF file');
    }
  };

  const processPdf = async () => {
    if (!file) {
      setError('Please select a PDF file first');
      return;
    }

    setLoading(true);
    setError('');

    try {
      // Extract text from PDF
      const text = await extractTextFromPDF(file);
      setPdfText(text);
      
      // Generate summary
      const summary = await summarizeText(text);
      
      // Generate quiz
      const quiz = await generateQuiz(summary);
      setQuizData(quiz);
      setUserAnswers(new Array(quiz.questions.length).fill(null));
      
    } catch (err) {
      setError('Error: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  const handleAnswerSelect = (questionIndex, answerIndex) => {
    const newAnswers = [...userAnswers];
    newAnswers[questionIndex] = answerIndex;
    setUserAnswers(newAnswers);
  };

  const calculateScore = () => {
    let totalScore = 0;
    quizData.questions.forEach((question, index) => {
      if (userAnswers[index] !== null) {
        const selectedOption = question.options[userAnswers[index]];
        if (selectedOption === question.correctAnswer) {
          totalScore += POINTS_PER_QUESTION;
        }
      }
    });
    setScore(totalScore);
    setShowResults(true);
  };

  const resetQuiz = () => {
    setFile(null);
    setQuizData(null);
    setUserAnswers([]);
    setScore(0);
    setShowResults(false);
    setCurrentQuestion(0);
    setPdfText('');
  };

  if (showResults && quizData) {
    return (
      <Box sx={{ maxWidth: 800, margin: 'auto', padding: 3 }}>
        <Card>
          <CardContent>
            <Typography variant="h4" gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Score /> Quiz Results
            </Typography>
            
            <Typography variant="h6" gutterBottom>
              Your Score: {score} points out of {quizData.questions.length * POINTS_PER_QUESTION}
            </Typography>

            <TableContainer component={Paper} sx={{ mt: 2 }}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Question #</TableCell>
                    <TableCell>Your Answer</TableCell>
                    <TableCell>Correct Answer</TableCell>
                    <TableCell>Result</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {quizData.questions.map((question, index) => {
                    const userAnswer = userAnswers[index] !== null ? question.options[userAnswers[index]] : 'No Answer';
                    const isCorrect = userAnswer === question.correctAnswer;
                    
                    return (
                      <TableRow key={index}>
                        <TableCell>{index + 1}</TableCell>
                        <TableCell>{userAnswer}</TableCell>
                        <TableCell>{question.correctAnswer}</TableCell>
                        <TableCell>
                          {isCorrect ? '✅' : '❌'}
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </TableContainer>

            <Button 
              variant="contained" 
              onClick={resetQuiz}
              sx={{ mt: 3 }}
            >
              Start New Quiz
            </Button>
          </CardContent>
        </Card>
      </Box>
    );
  }

  if (quizData) {
    const currentQ = quizData.questions[currentQuestion];
    
    return (
      <Box sx={{ maxWidth: 600, margin: 'auto', padding: 3 }}>
        <Card>
          <CardContent>
            <Typography variant="h5" gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Quiz /> Question {currentQuestion + 1} of {quizData.questions.length}
            </Typography>
            
            <Typography variant="h6" gutterBottom sx={{ mb: 3 }}>
              {currentQ.question}
            </Typography>

            <RadioGroup
              value={userAnswers[currentQuestion] !== null ? userAnswers[currentQuestion].toString() : ''}
              onChange={(e) => handleAnswerSelect(currentQuestion, parseInt(e.target.value))}
            >
              {currentQ.options.map((option, optIndex) => (
                <FormControlLabel
                  key={optIndex}
                  value={optIndex.toString()}
                  control={<Radio />}
                  label={option}
                  sx={{ mb: 1, border: '1px solid #ddd', borderRadius: 1, padding: 1 }}
                />
              ))}
            </RadioGroup>

            <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
              <Button
                variant="outlined"
                onClick={() => setCurrentQuestion(Math.max(0, currentQuestion - 1))}
                disabled={currentQuestion === 0}
              >
                Previous
              </Button>
              
              {currentQuestion < quizData.questions.length - 1 ? (
                <Button
                  variant="contained"
                  onClick={() => setCurrentQuestion(currentQuestion + 1)}
                  disabled={userAnswers[currentQuestion] === null}
                >
                  Next
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="success"
                  onClick={calculateScore}
                  disabled={userAnswers[currentQuestion] === null}
                >
                  Submit Quiz
                </Button>
              )}
            </Box>
          </CardContent>
        </Card>
      </Box>
    );
  }

  return (
    <Box sx={{ maxWidth: 600, margin: 'auto', padding: 3 }}>
      <Card>
        <CardContent>
          <Typography variant="h4" gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Description /> PDF to Quiz Generator
          </Typography>
          
          <Typography variant="body1" paragraph>
            Upload a PDF file to generate an interactive quiz based on its content.
          </Typography>

          <Box sx={{ mb: 3 }}>
            <input
              accept=".pdf"
              style={{ display: 'none' }}
              id="pdf-upload"
              type="file"
              onChange={handleFileUpload}
            />
            <label htmlFor="pdf-upload">
              <Button
                variant="outlined"
                component="span"
                startIcon={<CloudUpload />}
                sx={{ mr: 2 }}
              >
                Upload PDF
              </Button>
            </label>
            
            {file && (
              <Typography variant="body2" sx={{ mt: 1 }}>
                Selected: {file.name}
              </Typography>
            )}
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <Button
            variant="contained"
            onClick={processPdf}
            disabled={!file || loading}
            startIcon={loading ? <CircularProgress size={20} /> : <Quiz />}
          >
            {loading ? 'Processing PDF...' : 'Generate Quiz'}
          </Button>

          {loading && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="body2" color="text.secondary">
                Extracting text and generating quiz questions...
              </Typography>
              <CircularProgress size={24} sx={{ mt: 1 }} />
            </Box>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default PdfToQuiz;
